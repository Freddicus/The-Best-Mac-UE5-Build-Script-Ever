#!/usr/bin/env bash

set -euo pipefail

# Preserve original stdout/stderr for human-facing status lines (FD 3/4)
exec 3>&1 4>&2

### ============================================================================
### USER CONFIG (safe to publish)
###
### Goal: Build + archive + sign + (optionally) notarize a macOS Unreal project.
###
### How to use:
###   - Leave the PROMPT overrides commented out to be asked interactively.
###   - Or uncomment and set overrides to make it non-interactive / CI-friendly.
###   - You can also export environment variables instead of editing this file.
###   - Or pass command-line flags (highest priority):
###       ./build_archive_sign_notarize_macos.sh --repo-root "/path" --uproject "MyGame.uproject" --ue-root "/Users/Shared/Epic Games/UE_5.x"
###
### Priority order:
###   CLI flags > environment vars > defaults in this file
###
### IMPORTANT: Replace any __REPLACE_ME__ placeholders before running.
### ============================================================================

# --- Project paths ---
# Path to your Unreal project root (the folder that contains the .uproject).
REPO_ROOT_DEFAULT="__REPLACE_ME__/YourProjectRoot"

# Name of your .uproject file.
UPROJECT_NAME_DEFAULT="__REPLACE_ME__.uproject"

# Path to your Xcode workspace generated by Unreal (if you use the Xcode archive step).
# NOTE: This is created by Unreal's GenerateProjectFiles on macOS.
XCODE_WORKSPACE_DEFAULT="__REPLACE_ME__.xcworkspace"

# Xcode scheme must be Shared (seen by `xcodebuild -list -workspace ...`)
XCODE_SCHEME_DEFAULT="__REPLACE_ME__"


# Optional: Where to place build artifacts/logs. Defaults under the repo root.
BUILD_DIR_DEFAULT="Build"
LOG_DIR_DEFAULT="Logs"

# --- Naming ---
# SHORT_NAME: used for archive/export file/folder names (keep it simple; no spaces recommended).
# LONG_NAME: used for the final zip filename and any user-facing labels.
SHORT_NAME_DEFAULT="__REPLACE_ME__"
LONG_NAME_DEFAULT="__REPLACE_ME__"

# --- Behavior toggles ---
# USE_XCODE_EXPORT:
#   1 = use Xcode archive/export (`xcodebuild archive` + `-exportArchive`) to produce the signed app.
#   0 = skip Xcode and attempt to sign/notarize the packaged `.app` produced by UAT.
#
# Xcode export is the most consistent route for Developer ID distribution, but not everyone wants/needs it.
USE_XCODE_EXPORT_DEFAULT="1"  # 1 = on (default), 0 = off

# CLEAN_BUILD_DIR:
#   1 = wipe the entire Build/ dir each run (more deterministic, more destructive)
#   0 = only remove the specific outputs this script produces (safer default)
CLEAN_BUILD_DIR_DEFAULT="0"

# DRY_RUN:
#   1 = print what would happen (and resolved paths), then exit
#   0 = run normally
DRY_RUN_DEFAULT="0"

# PRINT_CONFIG:
#   1 = print resolved configuration (paths/flags), then exit
#   0 = run normally
PRINT_CONFIG_DEFAULT="0"

# NOTE: Spaces are allowed in paths on macOS, but they can complicate shells/CI.
# This script will warn if it detects spaces so you can decide if you want to rename.


# --- Unreal Engine location ---
# Option A: Set UE_ROOT to your engine install folder, e.g.:
#   /Users/Shared/Epic Games/UE_5.4
#   /Users/Shared/Epic Games/UE_5.5
#   /Users/Shared/Epic Games/UE_5.7
#   /Users/Shared/Epic Games/UE_5.x (custom)
UE_ROOT_DEFAULT="__REPLACE_ME__/UE_5.x"

# Option B: If you already have these exact paths, you can set them directly.
# If UE_ROOT is set correctly, these will be derived automatically.
UAT_SCRIPTS_SUBPATH_DEFAULT="Engine/Build/BatchFiles"
UE_EDITOR_SUBPATH_DEFAULT="Engine/Binaries/Mac/UnrealEditor.app/Contents/MacOS/UnrealEditor"


# --- Signing / notarization ---
# Developer Team ID (for Xcode automatic signing). Find in Apple Developer → Membership.
DEVELOPMENT_TEAM_DEFAULT="__REPLACE_ME__"

# Developer ID Application signing identity (for codesign).
# Example format: "Developer ID Application: Your Company Name (TEAMID)"
SIGN_IDENTITY_DEFAULT="__REPLACE_ME__"

# ExportOptions.plist used by `xcodebuild -exportArchive`.
# You can keep one in the repo (recommended) or point at an absolute path.
EXPORT_PLIST_DEFAULT="__REPLACE_ME__/ExportOptions.plist"

# Notarytool keychain profile name.
# You create this once with: `xcrun notarytool store-credentials "NAME" ...`
NOTARY_PROFILE_DEFAULT="__REPLACE_ME__"


# --- Optional Steam support (disabled by default) ---
# This script can optionally stage + sign Steam's libsteam_api.dylib and optionally
# write steam_appid.txt for local (non-Steam-client) testing.
#
# If you are NOT using Steam, leave ENABLE_STEAM=0 and the script will skip all Steam steps.
ENABLE_STEAM_DEFAULT="0"   # 0 = off, 1 = on

# Steam App ID (only used when ENABLE_STEAM=1 AND WRITE_STEAM_APPID=1).
STEAM_APP_ID_DEFAULT="480" # Spacewar (testing). Replace with your real App ID if needed.

# Write steam_appid.txt next to the executable for local launches (not Steam Client launches).
WRITE_STEAM_APPID_DEFAULT="0"  # 0 = don't write, 1 = write

# Path to libsteam_api.dylib you want to bundle/sign.
# If you use UE's bundled Steamworks SDK, this is usually under Engine/Source/ThirdParty.
STEAM_DYLIB_SRC_DEFAULT="__REPLACE_ME__/libsteam_api.dylib"


# -----------------------------------------------------------------------------
# PROMPT OVERRIDES (optional)
# Uncomment to skip prompts.
# -----------------------------------------------------------------------------

# BUILD_TYPE_OVERRIDE="shipping"      # "shipping" or "development"
# NOTARIZE_OVERRIDE="yes"             # "yes" or "no"

# ENABLE_STEAM_OVERRIDE="0"           # "0" or "1"
# WRITE_STEAM_APPID_OVERRIDE="0"      # "0" or "1"
# STEAM_APP_ID_OVERRIDE="480"


### ============================================================================
### INTERNALS
### ============================================================================

die()  { echo "❌ $*" >&3; exit 1; }
warn() { echo "⚠️  $*" >&3; }
info() { echo "== $* ==" >&3; }

is_placeholder() {
  local v="${1:-}"
  [[ -z "$v" || "$v" == *"__REPLACE_ME__"* ]]
}


require_not_placeholder() {
  local name="$1"; local value="$2"; local hint="$3"
  if is_placeholder "$value"; then
    if [[ "${PRINT_CONFIG:-0}" == "1" ]]; then
      print_config
    fi
    die "$name is not configured. Set it via env var, edit the USER CONFIG block, or provide an override. Hint: $hint"
  fi
}

# -----------------------------------------------------------------------------
# Helpers for config discovery / printing
# -----------------------------------------------------------------------------

read_uproject_module_name() {
  # Extract the first module name from a .uproject (JSON) without python/jq.
  # This is a best-effort parser designed for typical Unreal .uproject formatting.
  #
  # It looks for: "Modules": [ { "Name": "YourModule", ... }, ... ]
  local uproject_path="$1"
  [[ -f "$uproject_path" ]] || { echo ""; return 0; }

  /usr/bin/awk '
    BEGIN {
      in_modules = 0
      bracket_depth = 0
    }

    # Once we enter the Modules array, track [] depth so we know when it ends.
    {
      line = $0
    }

    # Enter Modules section when we see "Modules"
    !in_modules && line ~ /"Modules"[[:space:]]*:/ {
      in_modules = 1
    }

    # If we are in Modules, update bracket depth for [ and ] on this line.
    in_modules {
      # Count [ and ] occurrences (simple but effective for .uproject files)
      open = gsub(/\[/, "[", line)
      close = gsub(/\]/, "]", line)
      bracket_depth += (open - close)

      # Look for the first "Name": "..."
      # Capture the first quoted string after "Name":
      if (match(line, /"Name"[[:space:]]*:[[:space:]]*"[^"]+"/)) {
        s = substr(line, RSTART, RLENGTH)
        sub(/^.*"Name"[[:space:]]*:[[:space:]]*"/, "", s)
        sub(/".*$/, "", s)
        print s
        exit 0
      }

      # If bracket_depth drops to 0 or below, we have left the array.
      # (In practice, it should be 0 at the end of the array.)
      if (bracket_depth <= 0) {
        exit 0
      }
    }

    END { }
  ' "$uproject_path" 2>/dev/null || true
}

autodetect_uproject_if_needed() {
  if is_placeholder "${UPROJECT_NAME:-}"; then
    local found=()
    while IFS= read -r line; do
      [[ -n "$line" ]] && found+=("$line")
    done < <(/usr/bin/find "$REPO_ROOT" -maxdepth 1 -type f -name '*.uproject' 2>/dev/null)

    if [[ "${#found[@]}" -eq 1 ]]; then
      UPROJECT_PATH="${found[0]}"
      UPROJECT_NAME="$(/usr/bin/basename "$UPROJECT_PATH")"
      info "Auto-detected .uproject: $UPROJECT_NAME"
    elif [[ "${#found[@]}" -gt 1 ]]; then
      echo "Found multiple .uproject candidates:" >&3
      printf '  - %s\n' "${found[@]}" >&3
      die "Multiple .uproject files found. Pass --uproject explicitly."
    else
      die "No .uproject found in REPO_ROOT. Put the script in the project root or pass --repo-root."
    fi
  fi
}

autodetect_names_if_needed() {
  local base
  base="${UPROJECT_NAME%.uproject}"

  if is_placeholder "${LONG_NAME:-}"; then
    LONG_NAME="$base"
    info "Auto-detected LONG_NAME: $LONG_NAME"
  fi

  if is_placeholder "${SHORT_NAME:-}"; then
    SHORT_NAME="$base"
    SHORT_NAME="${SHORT_NAME// /}"  # conservative
    info "Auto-detected SHORT_NAME: $SHORT_NAME"
  fi
}

autodetect_workspace_guess_if_needed() {
  # If workspace is placeholder, try Unreal's common naming convention: "<Project> (Mac).xcworkspace".
  if [[ "$USE_XCODE_EXPORT" == "1" ]] && is_placeholder "$XCODE_WORKSPACE"; then
    local base guess
    base="${UPROJECT_NAME%.uproject}"
    guess="$REPO_ROOT/${base} (Mac).xcworkspace"
    if [[ -d "$guess" ]]; then
      XCODE_WORKSPACE="$(/usr/bin/basename "$guess")"
      WORKSPACE="$guess"
      info "Auto-detected workspace by convention: $WORKSPACE"
    fi
  fi
}

autodetect_export_plist_if_needed() {
  # If export plist is placeholder, try a repo-local ExportOptions.plist.
  if is_placeholder "$EXPORT_PLIST"; then
    local candidate="$REPO_ROOT/ExportOptions.plist"
    if [[ -f "$candidate" ]]; then
      EXPORT_PLIST="$candidate"
      info "Auto-detected ExportOptions.plist: $EXPORT_PLIST"
    fi
  fi
}

sanitize_name_for_tmp() {
  # mktemp's -t template is happier without spaces/special chars.
  local v="$1"
  v="${v// /_}"
  v="${v//[^a-zA-Z0-9._-]/_}"
  echo "$v"
}

print_config() {
  echo "== Resolved configuration ==" >&3
  echo "REPO_ROOT:         $REPO_ROOT" >&3
  echo "UPROJECT_PATH:     $UPROJECT_PATH" >&3
  echo "UE_ROOT:           $UE_ROOT" >&3
  echo "UAT (RunUAT.sh):   $SCRIPTS/RunUAT.sh" >&3
  echo "UE_EDITOR:         $UE_EDITOR" >&3
  echo "BUILD_DIR:         $BUILD_DIR" >&3
  echo "LOG_DIR:           $LOG_DIR" >&3
  echo "SHORT_NAME:        $SHORT_NAME" >&3
  echo "LONG_NAME:         $LONG_NAME" >&3
  echo "USE_XCODE_EXPORT:  $USE_XCODE_EXPORT" >&3
  echo "CLEAN_BUILD_DIR:   $CLEAN_BUILD_DIR" >&3
  echo "DRY_RUN:           $DRY_RUN" >&3
  echo "PRINT_CONFIG:      $PRINT_CONFIG" >&3
  echo "ENABLE_STEAM:      $ENABLE_STEAM" >&3
  echo "WRITE_STEAM_APPID: $WRITE_STEAM_APPID" >&3
  if [[ "$USE_XCODE_EXPORT" == "1" ]]; then
    echo "WORKSPACE:         $WORKSPACE" >&3
    echo "SCHEME:            $SCHEME" >&3
    echo "XCODE_CONFIG:      ${XCODE_CONFIG:-<unset>}" >&3
  fi
  echo "DO_NOTARIZE:       ${DO_NOTARIZE:-<unset>}" >&3
  if [[ "$USE_XCODE_EXPORT" == "1" ]]; then
    echo "EXPORT_PLIST:      $EXPORT_PLIST" >&3
  fi
}

autodetect_workspace_if_needed() {
  # If the workspace is placeholder/empty AND Xcode export is enabled, try to discover it.
  if [[ "$USE_XCODE_EXPORT" == "1" ]] && is_placeholder "$XCODE_WORKSPACE"; then
    info "XCODE_WORKSPACE not set — attempting auto-detect"
    local found=()
    while IFS= read -r line; do
      [[ -n "$line" ]] && found+=("$line")
    done < <(/usr/bin/find "$REPO_ROOT" -maxdepth 2 -type d -name '*.xcworkspace' 2>/dev/null)
    if [[ "${#found[@]}" -eq 1 ]]; then
      XCODE_WORKSPACE="$(/usr/bin/basename "${found[0]}")"
      WORKSPACE="${found[0]}"
      info "Auto-detected workspace: $WORKSPACE"
    elif [[ "${#found[@]}" -eq 0 ]]; then
      die "No .xcworkspace found under REPO_ROOT. Generate it (GenerateProjectFiles) or set XCODE_WORKSPACE."
    else
      # Common Unreal output: both "<Project> (iOS).xcworkspace" and "<Project> (Mac).xcworkspace".
      # Prefer the macOS workspace automatically when present.
      local mac_found=()
      local p
      for p in "${found[@]}"; do
        if [[ "$p" == *" (Mac).xcworkspace" ]]; then
          mac_found+=("$p")
        fi
      done

      if [[ "${#mac_found[@]}" -eq 1 ]]; then
        XCODE_WORKSPACE="$(/usr/bin/basename "${mac_found[0]}")"
        WORKSPACE="${mac_found[0]}"
        info "Auto-selected macOS workspace: $WORKSPACE"
      elif [[ "${#mac_found[@]}" -gt 1 ]]; then
        # If there are multiple macOS workspaces, prefer the one that matches the project naming convention.
        local base expected matches=()
        base="${UPROJECT_NAME%.uproject}"
        expected="$REPO_ROOT/${base} (Mac).xcworkspace"

        for p in "${mac_found[@]}"; do
          if [[ "$p" == "$expected" ]]; then
            matches+=("$p")
          fi
        done

        if [[ "${#matches[@]}" -eq 1 ]]; then
          XCODE_WORKSPACE="$(/usr/bin/basename "${matches[0]}")"
          WORKSPACE="${matches[0]}"
          info "Auto-selected macOS workspace (matched convention): $WORKSPACE"
        else
          echo "Found multiple macOS .xcworkspace candidates:" >&3
          printf '  - %s\n' "${mac_found[@]}" >&3
          die "Multiple macOS workspaces found. Set XCODE_WORKSPACE explicitly."
        fi
      else
        # No macOS workspace found — show candidates and instruct.
        echo "Found multiple .xcworkspace candidates (but none look like a macOS workspace):" >&3
        printf '  - %s\n' "${found[@]}" >&3
        die "No '(Mac).xcworkspace' found. Generate Mac project files or set XCODE_WORKSPACE explicitly."
      fi
    fi
  fi
}

autodetect_scheme_if_needed() {
  # If scheme is placeholder/empty AND Xcode export is enabled, try to discover it from xcodebuild.
  if [[ "$USE_XCODE_EXPORT" == "1" ]] && is_placeholder "$XCODE_SCHEME"; then
    info "XCODE_SCHEME not set — attempting auto-detect"

    local list
    list=$(xcodebuild -list -workspace "$WORKSPACE" 2>/dev/null || true)
    if [[ -z "$list" ]]; then
      die "Could not list schemes from workspace. Open the workspace in Xcode and ensure a Shared scheme exists."
    fi

    local schemes=()
    local in_section=0

    while IFS= read -r line; do
      # Look for the "Schemes:" header (it may be indented in some Xcode versions).
      if [[ "$in_section" -eq 0 ]]; then
        if [[ "$line" =~ ^[[:space:]]*Schemes:[[:space:]]*$ ]]; then
          in_section=1
        fi
        continue
      fi

      # Once in the schemes section:
      # - collect indented, non-empty lines
      # - ignore blank lines
      # - stop when we hit a non-indented line
      if [[ -z "$line" ]]; then
        continue
      fi

      if [[ "$line" =~ ^[[:space:]]+[^[:space:]] ]]; then
        # Trim leading whitespace
        local trimmed
        trimmed="${line#${line%%[![:space:]]*}}"
        schemes+=("$trimmed")
      else
        break
      fi
    done <<< "$list"

    if [[ "${#schemes[@]}" -eq 1 ]]; then
      XCODE_SCHEME="${schemes[0]}"
      SCHEME="$XCODE_SCHEME"
      info "Auto-detected scheme: $SCHEME"

    elif [[ "${#schemes[@]}" -eq 0 ]]; then
      die "No schemes found in workspace. Make sure the scheme exists and is marked Shared (Product → Scheme → Manage Schemes…)."

    else
      # Prefer an exact match to the detected project/app name.
      local base module preferred chosen=""
      base="${UPROJECT_NAME%.uproject}"
      module="$(read_uproject_module_name "$UPROJECT_PATH")"

      preferred=""
      if ! is_placeholder "$LONG_NAME"; then
        preferred="$LONG_NAME"
      elif [[ -n "$module" ]]; then
        preferred="$module"
      else
        preferred="$base"
      fi

      # Try to choose a single exact match in priority order.
      local candidates=()
      candidates+=("$preferred")
      [[ -n "$module" ]] && candidates+=("$module")
      candidates+=("$base")
      if ! is_placeholder "$SHORT_NAME"; then
        candidates+=("$SHORT_NAME")
      fi

      local c s
      for c in "${candidates[@]}"; do
        for s in "${schemes[@]}"; do
          if [[ "$s" == "$c" ]]; then
            chosen="$s"
            break 2
          fi
        done
      done

      if [[ -n "$chosen" ]]; then
        XCODE_SCHEME="$chosen"
        SCHEME="$XCODE_SCHEME"
        info "Auto-selected scheme by exact match: $SCHEME"

        echo "Schemes (auto-selected):" >&3
        for s in "${schemes[@]}"; do
          if [[ "$s" == "$chosen" ]]; then
            echo "  -> $s" >&3
          else
            echo "     $s" >&3
          fi
        done
      else
        echo "Available schemes:" >&3
        printf '  - %s\n' "${schemes[@]}" >&3
        die "Multiple schemes found and none matched the detected name. Set XCODE_SCHEME explicitly."
      fi
    fi
  fi
}


find_first_app_under() {
  # Find the first .app bundle under a root (prefers shallow paths; returns empty if none).
  local root="$1"
  /usr/bin/find "$root" -maxdepth 5 -type d -name '*.app' -print -quit 2>/dev/null || true
}

abspath_existing() {
  # Convert an existing file/dir path to an absolute, physical path.
  # Returns empty string if the target does not exist or cannot be resolved.
  local p="$1"
  [[ -n "$p" ]] || { echo ""; return 0; }
  [[ -e "$p" ]] || { echo ""; return 0; }

  local dir base absdir
  dir="$(/usr/bin/dirname "$p")"
  base="$(/usr/bin/basename "$p")"

  absdir="$((/bin/cd "$dir" 2>/dev/null && /bin/pwd -P) 2>/dev/null)"
  if [[ -z "$absdir" ]]; then
    echo ""
    return 0
  fi

  echo "$absdir/$base"
}

abspath_from() {
  # Resolve a (possibly relative) path against a base directory.
  # Does not require the target to exist.
  local base="$1"
  local p="$2"
  [[ -n "$p" ]] || { echo ""; return 0; }
  if [[ "$p" == /* ]]; then
    echo "$p"; return 0
  fi
  local d
  d="$(/bin/cd "$base" 2>/dev/null && /bin/pwd -P)" || { echo ""; return 0; }
  echo "$d/$p"
}

read_ini_value() {
  # first match only; expects Key=Value
  local file="$1"; local key="$2"
  [[ -f "$file" ]] || { echo ""; return 0; }

  local line val
  line="$(/usr/bin/grep -E "^[[:space:]]*${key}[[:space:]]*=" "$file" 2>/dev/null | /usr/bin/head -n 1 || true)"
  [[ -n "$line" ]] || { echo ""; return 0; }

  val="${line#*=}"
  val="${val#${val%%[![:space:]]*}}"
  val="${val%${val##*[![:space:]]}}"
  val="${val%\"}"; val="${val#\"}"
  val="${val%%;*}"; val="${val%%#*}"
  val="${val#${val%%[![:space:]]*}}"
  val="${val%${val##*[![:space:]]}}"
  echo "$val"
}

detect_steam_from_ini() {
  local engine_ini="$REPO_ROOT/Config/DefaultEngine.ini"
  [[ -f "$engine_ini" ]] || return 1

  /usr/bin/grep -qiE "OnlineSubsystemSteam|DefaultPlatformService[[:space:]]*=[[:space:]]*Steam" "$engine_ini" && return 0

  /usr/bin/awk '
    BEGIN{in=0}
    /^\[/ {in=0}
    /^\[\/Script\/OnlineSubsystemSteam\.OnlineSubsystemSteam\]/ {in=1}
    in && /^[[:space:]]*bEnabled[[:space:]]*=[[:space:]]*true/ {found=1}
    END{exit(found?0:1)}
  ' "$engine_ini" 2>/dev/null && return 0

  return 1
}

autodetect_steam_if_needed() {
  if [[ "${CLI_SET_ENABLE_STEAM:-0}" != "1" && "${ENABLE_STEAM:-0}" == "0" ]]; then
    if detect_steam_from_ini; then
      ENABLE_STEAM="1"
      info "Detected Steam OSS in Config/DefaultEngine.ini — ENABLE_STEAM=1"

      local engine_ini="$REPO_ROOT/Config/DefaultEngine.ini"
      local appid
      appid="$(read_ini_value "$engine_ini" "SteamDevAppId")"
      [[ -z "$appid" ]] && appid="$(read_ini_value "$engine_ini" "SteamAppId")"
      if [[ -n "$appid" ]]; then
        STEAM_APP_ID="$appid"
        info "Detected Steam App ID from INI: $STEAM_APP_ID"
      fi
    fi
  fi
}

read_steamworks_version_number() {
  # Extract SteamVersionNumber (e.g., 1.63) from Steamworks.build.cs (best-effort).
  local cs="$1"
  [[ -f "$cs" ]] || { echo ""; return 0; }

  # Example line: double SteamVersionNumber = 1.63;
  /usr/bin/awk '
    match($0, /SteamVersionNumber[[:space:]]*=[[:space:]]*[0-9]+\.[0-9]+/) {
      s=substr($0, RSTART, RLENGTH)
      sub(/^.*=/, "", s)
      gsub(/[[:space:]]*/, "", s)
      print s
      exit
    }
  ' "$cs" 2>/dev/null || true
}

steam_version_to_folder() {
  # Convert 1.63 -> Steamv163 (remove dot).
  local v="$1"
  [[ -n "$v" ]] || { echo ""; return 0; }
  local digits
  digits="${v//./}"
  echo "Steamv${digits}"
}

autodetect_steam_dylib_src_from_engine_if_needed() {
  # If Steam is enabled and STEAM_DYLIB_SRC is placeholder, try to locate it inside UE_ROOT.
  # Expected layout:
  #   <UE_ROOT>/Engine/Source/ThirdParty/Steamworks/Steamv163/sdk/redistributable_bin/osx/libsteam_api.dylib
  #
  # We do NOT assume a specific UE version; we derive everything from UE_ROOT.

  [[ "${ENABLE_STEAM:-0}" == "1" ]] || return 0
  is_placeholder "${STEAM_DYLIB_SRC:-}" || return 0

  local steam_root cs ver folder candidate
  steam_root="$UE_ROOT/Engine/Source/ThirdParty/Steamworks"
  cs="$steam_root/Steamworks.build.cs"

  if [[ ! -d "$steam_root" ]]; then
    # Some engine installs may omit ThirdParty sources; don't fail here.
    warn "ENABLE_STEAM=1 but Steamworks ThirdParty folder not found under UE_ROOT: $steam_root"
    return 0
  fi

  if [[ ! -f "$cs" ]]; then
    warn "Steamworks.build.cs not found (cannot auto-detect Steam SDK version): $cs"
    return 0
  fi

  ver="$(read_steamworks_version_number "$cs")"
  folder="$(steam_version_to_folder "$ver")"

  if [[ -z "$folder" ]]; then
    warn "Could not parse SteamVersionNumber from: $cs"
    return 0
  fi

  candidate="$steam_root/$folder/sdk/redistributable_bin/osx/libsteam_api.dylib"
  if [[ -f "$candidate" ]]; then
    STEAM_DYLIB_SRC="$candidate"
    info "Auto-detected STEAM_DYLIB_SRC from UE_ROOT ($folder): $STEAM_DYLIB_SRC"
    return 0
  fi

  # Fallback: if expected folder isn't present, try to find any matching dylib under Steamworks.
  local found
  found="$(/usr/bin/find "$steam_root" -maxdepth 6 -type f -name 'libsteam_api.dylib' -path '*/redistributable_bin/osx/*' -print -quit 2>/dev/null || true)"
  if [[ -n "$found" && -f "$found" ]]; then
    STEAM_DYLIB_SRC="$found"
    info "Auto-detected STEAM_DYLIB_SRC by search under Steamworks: $STEAM_DYLIB_SRC"
    return 0
  fi

  warn "ENABLE_STEAM=1 but could not locate libsteam_api.dylib under: $steam_root"
  warn "Expected (based on SteamVersionNumber=$ver): $candidate"
  warn "Set STEAM_DYLIB_SRC explicitly (--steam-dylib-src or env/USER CONFIG) if your layout differs."
}

#
# Allow environment variables to override defaults without editing the script.
REPO_ROOT="${REPO_ROOT:-$REPO_ROOT_DEFAULT}"
UPROJECT_NAME="${UPROJECT_NAME:-$UPROJECT_NAME_DEFAULT}"
XCODE_WORKSPACE="${XCODE_WORKSPACE:-$XCODE_WORKSPACE_DEFAULT}"
XCODE_SCHEME="${XCODE_SCHEME:-$XCODE_SCHEME_DEFAULT}"
BUILD_DIR_REL="${BUILD_DIR_REL:-$BUILD_DIR_DEFAULT}"
LOG_DIR_REL="${LOG_DIR_REL:-$LOG_DIR_DEFAULT}"

SHORT_NAME="${SHORT_NAME:-$SHORT_NAME_DEFAULT}"
LONG_NAME="${LONG_NAME:-$LONG_NAME_DEFAULT}"

USE_XCODE_EXPORT="${USE_XCODE_EXPORT:-$USE_XCODE_EXPORT_DEFAULT}"
CLEAN_BUILD_DIR="${CLEAN_BUILD_DIR:-$CLEAN_BUILD_DIR_DEFAULT}"
DRY_RUN="${DRY_RUN:-$DRY_RUN_DEFAULT}"
PRINT_CONFIG="${PRINT_CONFIG:-$PRINT_CONFIG_DEFAULT}"

UE_ROOT="${UE_ROOT:-$UE_ROOT_DEFAULT}"
UAT_SCRIPTS_SUBPATH="${UAT_SCRIPTS_SUBPATH:-$UAT_SCRIPTS_SUBPATH_DEFAULT}"
UE_EDITOR_SUBPATH="${UE_EDITOR_SUBPATH:-$UE_EDITOR_SUBPATH_DEFAULT}"

DEVELOPMENT_TEAM="${DEVELOPMENT_TEAM:-$DEVELOPMENT_TEAM_DEFAULT}"
SIGN_IDENTITY="${SIGN_IDENTITY:-$SIGN_IDENTITY_DEFAULT}"
EXPORT_PLIST="${EXPORT_PLIST:-$EXPORT_PLIST_DEFAULT}"
NOTARY_PROFILE="${NOTARY_PROFILE:-$NOTARY_PROFILE_DEFAULT}"

ENABLE_STEAM="${ENABLE_STEAM:-$ENABLE_STEAM_DEFAULT}"
STEAM_APP_ID="${STEAM_APP_ID:-$STEAM_APP_ID_DEFAULT}"
WRITE_STEAM_APPID="${WRITE_STEAM_APPID:-$WRITE_STEAM_APPID_DEFAULT}"
STEAM_DYLIB_SRC="${STEAM_DYLIB_SRC:-$STEAM_DYLIB_SRC_DEFAULT}"


# -----------------------------------------------------------------------------
# Command-line flag overrides (highest priority)
# -----------------------------------------------------------------------------

usage() {
  cat >&3 <<'USAGE'
Usage:
  ./build_archive_sign_notarize_macos.sh [options]

Options (override env/defaults):
  --repo-root PATH
  --uproject FILE_OR_PATH            (e.g. MyGame.uproject)
  --ue-root PATH
  --xcode-workspace FILE_OR_PATH     (e.g. "MyGame (Mac).xcworkspace")
  --xcode-scheme NAME
  --development-team TEAMID
  --sign-identity "Developer ID Application: ... (TEAMID)"
  --export-plist PATH
  --notary-profile NAME

  --short-name NAME
  --long-name NAME

  --use-xcode-export 0|1
  --clean-build-dir 0|1
  --dry-run 0|1
  --print-config 0|1

  --enable-steam 0|1
  --write-steam-appid 0|1
  --steam-app-id ID
  --steam-dylib-src PATH

  --build-type shipping|development
  --notarize yes|no

  -h, --help
USAGE
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;

    --repo-root)            REPO_ROOT="$2"; shift 2 ;;
    --uproject)             UPROJECT_NAME="$2"; shift 2 ;;
    --ue-root)              UE_ROOT="$2"; shift 2 ;;
    --xcode-workspace)      XCODE_WORKSPACE="$2"; shift 2 ;;
    --xcode-scheme)         XCODE_SCHEME="$2"; shift 2 ;;

    --development-team)     DEVELOPMENT_TEAM="$2"; shift 2 ;;
    --sign-identity)        SIGN_IDENTITY="$2"; shift 2 ;;
    --export-plist)         EXPORT_PLIST="$2"; shift 2 ;;
    --notary-profile)       NOTARY_PROFILE="$2"; shift 2 ;;

    --short-name)           SHORT_NAME="$2"; shift 2 ;;
    --long-name)            LONG_NAME="$2"; shift 2 ;;

    --use-xcode-export)     USE_XCODE_EXPORT="$2"; shift 2 ;;
    --clean-build-dir)      CLEAN_BUILD_DIR="$2"; shift 2 ;;
    --dry-run)              DRY_RUN="$2"; shift 2 ;;
    --print-config)         PRINT_CONFIG="$2"; shift 2 ;;

    --enable-steam) ENABLE_STEAM="$2"; CLI_SET_ENABLE_STEAM=1; shift 2 ;;
    --write-steam-appid)    WRITE_STEAM_APPID="$2"; shift 2 ;;
    --steam-app-id)         STEAM_APP_ID="$2"; shift 2 ;;
    --steam-dylib-src)      STEAM_DYLIB_SRC="$2"; shift 2 ;;

    --build-type)           BUILD_TYPE_OVERRIDE="$2"; shift 2 ;;
    --notarize)             NOTARIZE_OVERRIDE="$2"; shift 2 ;;

    *) die "Unknown option: $1 (use --help)" ;;
  esac
done

# If REPO_ROOT is still a placeholder/empty, assume this script lives in the project root.
if is_placeholder "${REPO_ROOT:-}"; then
  SCRIPT_DIR="$(cd "$(/usr/bin/dirname "$0")" && pwd -P)"
  REPO_ROOT="$SCRIPT_DIR"
  info "REPO_ROOT not set — assuming script directory: $REPO_ROOT"
fi

if is_placeholder "$DEVELOPMENT_TEAM"; then
  ios_ini="$REPO_ROOT/Config/DefaultEngine.ini"
  team="$(read_ini_value "$ios_ini" "IOSTeamID")"
  if [[ -n "$team" ]]; then
    DEVELOPMENT_TEAM="$team"
    info "Detected DEVELOPMENT_TEAM from INI (IOSTeamID): $DEVELOPMENT_TEAM"
  fi
fi

# If the caller provided absolute paths for uproject/workspace, normalize them.
if [[ -n "${UPROJECT_NAME:-}" && "$UPROJECT_NAME" == /* ]]; then
  UPROJECT_PATH="$UPROJECT_NAME"
  UPROJECT_NAME="$(/usr/bin/basename "$UPROJECT_PATH")"
  REPO_ROOT="$(/usr/bin/dirname "$UPROJECT_PATH")"
fi

if [[ -n "${XCODE_WORKSPACE:-}" && "$XCODE_WORKSPACE" == /* ]]; then
  WORKSPACE="$XCODE_WORKSPACE"
  XCODE_WORKSPACE="$(/usr/bin/basename "$WORKSPACE")"
fi

# Normalize REPO_ROOT to an absolute path (best-effort).
# IMPORTANT: resolve relative paths (including ".") against the CURRENT working directory,
# not against "/".
if [[ -n "${REPO_ROOT:-}" && "$REPO_ROOT" != /* ]]; then
  REPO_ROOT="$(abspath_from "$(/bin/pwd -P)" "$REPO_ROOT")"
fi

# Auto-detect the .uproject, names, and common workspace naming convention when placeholders are used.
autodetect_uproject_if_needed

# Construct UPROJECT_PATH if it wasn't provided, then normalize it to an absolute path.
UPROJECT_PATH="${UPROJECT_PATH:-$REPO_ROOT/$UPROJECT_NAME}"
if [[ -f "$UPROJECT_PATH" ]]; then
  UPROJECT_PATH="$(abspath_existing "$UPROJECT_PATH")"
fi

# Ensure REPO_ROOT matches the actual uproject directory once we have the uproject path.
if [[ -n "${UPROJECT_PATH:-}" && -f "$UPROJECT_PATH" ]]; then
  REPO_ROOT="$(/usr/bin/dirname "$UPROJECT_PATH")"
fi

autodetect_names_if_needed

# Try the common "<Project> (Mac).xcworkspace" guess before the more general workspace find.
autodetect_workspace_guess_if_needed
autodetect_export_plist_if_needed
autodetect_steam_if_needed
autodetect_steam_dylib_src_from_engine_if_needed

# Derive common paths (after CLI parsing/autodetect)
REPO="$REPO_ROOT"
UPROJECT_PATH="${UPROJECT_PATH:-$REPO_ROOT/$UPROJECT_NAME}"
WORKSPACE="${WORKSPACE:-$REPO_ROOT/$XCODE_WORKSPACE}"
SCHEME="$XCODE_SCHEME"

SCRIPTS="$UE_ROOT/$UAT_SCRIPTS_SUBPATH"
UE_EDITOR="$UE_ROOT/$UE_EDITOR_SUBPATH"

# Artifact roots
BUILD_DIR="$REPO_ROOT/$BUILD_DIR_REL"
LOG_DIR="$REPO_ROOT/$LOG_DIR_REL"

# Normalize a few important paths to absolute paths when possible.
# (This helps when the user passes relative paths via env/CLI.)
if [[ -d "$WORKSPACE" ]]; then
  WORKSPACE="$(abspath_existing "$WORKSPACE")"
fi
if [[ -f "$EXPORT_PLIST" ]]; then
  _abs="$(abspath_existing "$EXPORT_PLIST")"
  [[ -n "${_abs:-}" ]] && EXPORT_PLIST="$_abs"
fi
if [[ "$ENABLE_STEAM" == "1" && -f "$STEAM_DYLIB_SRC" ]]; then
  _abs="$(abspath_existing "$STEAM_DYLIB_SRC")"
  [[ -n "${_abs:-}" ]] && STEAM_DYLIB_SRC="$_abs"
fi
unset _abs

#
# Validate required config early (fail fast with helpful messages)
require_not_placeholder "REPO_ROOT" "$REPO_ROOT" "Example: /Users/you/Documents/Unreal Projects/MyGame"
# At this point, autodetection should have filled these unless the repo is unusual.
require_not_placeholder "UPROJECT_NAME" "$UPROJECT_NAME" "Example: MyGame.uproject"
require_not_placeholder "UPROJECT_PATH" "$UPROJECT_PATH" "Example: /path/to/MyGame.uproject"
require_not_placeholder "UE_ROOT" "$UE_ROOT" "Example: /Users/Shared/Epic Games/UE_5.7"
require_not_placeholder "DEVELOPMENT_TEAM" "$DEVELOPMENT_TEAM" "Example: ABCDE12345"
require_not_placeholder "SIGN_IDENTITY" "$SIGN_IDENTITY" "Example: Developer ID Application: Your Company (ABCDE12345)"
require_not_placeholder "SHORT_NAME" "$SHORT_NAME" "Example: MG"
require_not_placeholder "LONG_NAME" "$LONG_NAME" "Example: MyGame"

# Xcode inputs are only required if you use the Xcode archive/export steps.
if [[ "$USE_XCODE_EXPORT" == "1" ]]; then
  # Ensure derived paths are available to autodetect.
  WORKSPACE="${WORKSPACE:-$REPO_ROOT/$XCODE_WORKSPACE}"
  SCHEME="$XCODE_SCHEME"

  # Try auto-detect first (helps new users).
  autodetect_workspace_if_needed
  autodetect_scheme_if_needed

  require_not_placeholder "EXPORT_PLIST" "$EXPORT_PLIST" "Point at an ExportOptions.plist compatible with Developer ID exports"
  require_not_placeholder "XCODE_WORKSPACE" "$XCODE_WORKSPACE" "Example: YourProject (Mac).xcworkspace"
  require_not_placeholder "XCODE_SCHEME" "$XCODE_SCHEME" "Example: YourProject"
fi

warn_if_has_spaces() {
  local name="$1"; local value="$2"
  if [[ "$value" == *" "* ]]; then
    warn "$name contains spaces: '$value'"
    warn "  This is supported, but can complicate CI/shell scripts. Consider renaming to remove spaces if you're early in the project."
  fi
}

warn_if_has_spaces "REPO_ROOT" "$REPO_ROOT"
warn_if_has_spaces "UPROJECT_NAME" "$UPROJECT_NAME"
warn_if_has_spaces "SHORT_NAME" "$SHORT_NAME"
warn_if_has_spaces "LONG_NAME" "$LONG_NAME"
if [[ "$USE_XCODE_EXPORT" == "1" ]]; then
  warn_if_has_spaces "XCODE_WORKSPACE" "$XCODE_WORKSPACE"
  warn_if_has_spaces "XCODE_SCHEME" "$XCODE_SCHEME"
fi

# Notary profile is only required if we actually notarize.
# If NOTARY_PROFILE is missing, we'll automatically skip notarization/stapling and explain how to configure it.
if [[ "${NOTARIZE_OVERRIDE:-}" == "yes" ]]; then
  : # user explicitly requested notarization; we'll validate later
elif [[ "${NOTARIZE_OVERRIDE:-}" == "no" ]]; then
  : # user explicitly disabled notarization
else
  : # we may ask later; do not fail early
fi

# Optional Steam validation (only when enabled)
if [[ "$ENABLE_STEAM" == "1" ]]; then
  if is_placeholder "$STEAM_DYLIB_SRC"; then
    die "ENABLE_STEAM=1 but STEAM_DYLIB_SRC is not set. The script tried to infer it from UE_ROOT but couldn't. Provide it via --steam-dylib-src (or env/USER CONFIG), or set ENABLE_STEAM=0."
  fi
fi

# Ask up-front (unless overridden)
if [[ -n "${BUILD_TYPE_OVERRIDE:-}" ]]; then
  case "${BUILD_TYPE_OVERRIDE,,}" in
    shipping|s)    BUILD_TYPE="s" ;;
    development|d) BUILD_TYPE="d" ;;
    *) die "BUILD_TYPE_OVERRIDE must be 'shipping' or 'development'" ;;
  esac
else
  read -r -p "Build type? (s=shipping, d=development) [s]: " BUILD_TYPE
  BUILD_TYPE=${BUILD_TYPE:-s}
fi

if [[ "$BUILD_TYPE" =~ ^[Dd]$ ]]; then
  UE_CLIENT_CONFIG="Development"
  XCODE_CONFIG="Development"
  info "Build type: DEVELOPMENT"
else
  UE_CLIENT_CONFIG="Shipping"
  XCODE_CONFIG="Shipping"
  info "Build type: SHIPPING"
fi

if [[ -n "${NOTARIZE_OVERRIDE:-}" ]]; then
  case "${NOTARIZE_OVERRIDE,,}" in
    yes|y) DO_NOTARIZE=0 ;;
    no|n)  DO_NOTARIZE=1 ;;
    *) die "NOTARIZE_OVERRIDE must be 'yes' or 'no'" ;;
  esac
else
  read -r -p "Notarize + staple this build? (Y/n) " NOTARIZE_ANSWER
  if [[ "${NOTARIZE_ANSWER:-Y}" =~ ^[Nn]$ ]]; then
    DO_NOTARIZE=1
  else
    DO_NOTARIZE=0
  fi
fi

# If notarization was requested but NOTARY_PROFILE isn't configured, auto-skip with guidance.
if [[ "$DO_NOTARIZE" -eq 0 ]] && is_placeholder "$NOTARY_PROFILE"; then
  warn "Notarization requested, but NOTARY_PROFILE is not configured."
  warn "Skipping notarization + stapling for this run."
  warn "To enable notarization, create a keychain profile and provide it via one of:"
  warn "  - Edit this script: set NOTARY_PROFILE_DEFAULT (or export NOTARY_PROFILE)"
  warn "  - CLI flag: --notary-profile \"MyNotaryProfile\""
  warn "Create the profile once with:" 
  warn "  xcrun notarytool store-credentials \"MyNotaryProfile\" --apple-id \"you@example.com\" --team-id \"$DEVELOPMENT_TEAM\" --password \"app-specific-password\""
  DO_NOTARIZE=1
fi

# Print resolved config and/or exit early if requested.
if [[ "$PRINT_CONFIG" == "1" ]]; then
  print_config
  exit 0
fi

if [[ "$DRY_RUN" == "1" ]]; then
  print_config
  echo "== DRY RUN ==" >&3
  echo "Would run: UAT BuildCookRun → (optional) Xcode archive/export → codesign → (optional) notarize+staple" >&3
  exit 0
fi

# Optional Steam overrides
if [[ -n "${ENABLE_STEAM_OVERRIDE:-}" ]]; then
  ENABLE_STEAM="$ENABLE_STEAM_OVERRIDE"
fi
if [[ -n "${WRITE_STEAM_APPID_OVERRIDE:-}" ]]; then
  WRITE_STEAM_APPID="$WRITE_STEAM_APPID_OVERRIDE"
fi
if [[ -n "${STEAM_APP_ID_OVERRIDE:-}" ]]; then
  STEAM_APP_ID="$STEAM_APP_ID_OVERRIDE"
fi

# Logging (keep logs OUTSIDE Build/, since Build/ is often wiped each run)
mkdir -p "$LOG_DIR"
LOG_FILE="$LOG_DIR/build_$(date +%Y-%m-%d_%H-%M-%S).log"
exec >>"$LOG_FILE" 2>&1
echo "Log file: $LOG_FILE" >&3

trap 'echo "❌ Script failed at line $LINENO" >&3; if [[ "${PRINT_CONFIG:-0}" == "1" ]]; then print_config; fi; exit 1' ERR

# Build outputs
ARCHIVE_PATH="$BUILD_DIR/${SHORT_NAME}.xcarchive"
EXPORT_DIR="$BUILD_DIR/${SHORT_NAME}-export"
ZIP_PATH="$BUILD_DIR/${LONG_NAME}.zip"

# NOTE: ZIP_PATH name is cosmetic (uses LONG_NAME). Change LONG_NAME to match your game.
### ===================================

echo "== Prep output locations ==" >&3
rm -rf "$ARCHIVE_PATH" "$EXPORT_DIR" "$ZIP_PATH"
if [[ "$CLEAN_BUILD_DIR" == "1" ]]; then
  warn "CLEAN_BUILD_DIR=1 — wiping entire build dir: $BUILD_DIR"
  rm -rf "$BUILD_DIR"
fi
mkdir -p "$BUILD_DIR"

info "Sanity checks"

# Basic file existence checks
[[ -d "$REPO_ROOT" ]] || die "REPO_ROOT does not exist: $REPO_ROOT"
[[ -f "$UPROJECT_PATH" ]] || die "UPROJECT not found: $UPROJECT_PATH"
[[ -d "$SCRIPTS" ]] || die "UAT scripts folder not found: $SCRIPTS"
[[ -x "$SCRIPTS/RunUAT.sh" ]] || die "RunUAT.sh not executable or missing: $SCRIPTS/RunUAT.sh"
[[ -x "$UE_EDITOR" ]] || die "UnrealEditor not found/executable: $UE_EDITOR"

# Tools used later
command -v codesign  >/dev/null 2>&1 || die "codesign not found (unexpected on macOS)."

# Xcode steps are optional
if [[ "$USE_XCODE_EXPORT" == "1" ]]; then
  # Xcode workspaces are directory bundles (".xcworkspace" folders), not regular files.
  [[ -d "$WORKSPACE" ]] || die "Xcode workspace not found (expected a .xcworkspace directory): $WORKSPACE"
  command -v xcodebuild >/dev/null 2>&1 || die "xcodebuild not found. Install Xcode and the Command Line Tools."
fi

# Notarization requires Apple tools and a configured notary profile
if [[ "$DO_NOTARIZE" -eq 0 ]]; then
  command -v xcrun >/dev/null 2>&1 || die "xcrun not found. Install Xcode Command Line Tools."
  if is_placeholder "$NOTARY_PROFILE"; then
    die "Internal error: DO_NOTARIZE=0 but NOTARY_PROFILE is not configured (should have been auto-disabled earlier)."
  fi
fi

# Export options plist must exist if you are exporting
if [[ "$USE_XCODE_EXPORT" == "1" ]]; then
  [[ -f "$EXPORT_PLIST" ]] || die "ExportOptions.plist not found: $EXPORT_PLIST"
fi

echo "== Building Game ==" >&3

"$SCRIPTS/RunUAT.sh" BuildCookRun \
  -unrealexe="$UE_EDITOR" \
  -project="$UPROJECT_PATH" \
  -noP4 -build -cook -pak -iostore \
  -targetplatform=Mac -clientconfig="$UE_CLIENT_CONFIG" \
  -stage -package \
  -archive -archivedirectory="$BUILD_DIR" \
  -utf8output -verbose

echo "== Note: UE clientconfig=$UE_CLIENT_CONFIG, Xcode configuration=$XCODE_CONFIG ==" >&3

if [[ "$USE_XCODE_EXPORT" == "1" ]]; then
  echo "== Archive (NO CLEAN) with Automatic signing ==" >&3
  xcodebuild \
    -workspace "$WORKSPACE" \
    -scheme "$SCHEME" \
    -configuration "$XCODE_CONFIG" \
    -archivePath "$ARCHIVE_PATH" \
    archive \
    CODE_SIGN_STYLE=Automatic \
    DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
    ENABLE_HARDENED_RUNTIME=YES \
    OTHER_CODE_SIGN_FLAGS="--timestamp"

  echo "== Export signed app for Developer ID ==" >&3
  # Minimal ExportOptions for direct download (Developer ID).
  # If you don't already have it, create the file with the XML below.
  xcodebuild -exportArchive \
    -archivePath "$ARCHIVE_PATH" \
    -exportPath "$EXPORT_DIR" \
    -exportOptionsPlist "$EXPORT_PLIST"
else
  info "USE_XCODE_EXPORT=0 — skipping Xcode archive/export"
fi

# Locate the .app bundle.
# - If using Xcode export, it should be in EXPORT_DIR.
# - If skipping Xcode, it should be somewhere under BUILD_DIR (UAT output layout varies).
if [[ "$USE_XCODE_EXPORT" == "1" ]]; then
  APP_PATH="$(find_first_app_under "$EXPORT_DIR")"
  if [[ -z "${APP_PATH:-}" ]]; then
    echo "ERROR: No .app found under export dir: $EXPORT_DIR" >&3
    ls -la "$EXPORT_DIR" || true
    exit 2
  fi
else
  APP_PATH="$(find_first_app_under "$BUILD_DIR")"
  if [[ -z "${APP_PATH:-}" ]]; then
    echo "ERROR: No .app found under build dir: $BUILD_DIR" >&3
    echo "UAT output layouts differ by project/settings. Try enabling Xcode export (USE_XCODE_EXPORT=1) or point the script at the correct output." >&3
    ls -la "$BUILD_DIR" || true
    exit 2
  fi
fi

echo "WRITE_STEAM_APPID: $WRITE_STEAM_APPID" >&3
echo "App: $APP_PATH" >&3

if [[ "$ENABLE_STEAM" == "1" ]]; then
  STEAM_APPID_PATH="$APP_PATH/Contents/MacOS/steam_appid.txt"
  if [[ "${WRITE_STEAM_APPID:-0}" == "1" ]]; then
    echo "== Write steam_appid.txt for local (non-Steam-client) launches (WRITE_STEAM_APPID=1) ==" >&3
    echo "$STEAM_APP_ID" > "$STEAM_APPID_PATH"
    chmod 644 "$STEAM_APPID_PATH"
  else
    # When launching from the Steam client, Steam provides the AppID and a steam_appid.txt can cause confusing test behavior.
    if [[ -f "$STEAM_APPID_PATH" ]]; then
      echo "== Removing steam_appid.txt (Steam client launch should not need it) ==" >&3
      rm -f "$STEAM_APPID_PATH"
    else
      echo "== Not writing steam_appid.txt (Steam client launch should not need it) ==" >&3
    fi
  fi
else
  info "Steam disabled (ENABLE_STEAM=0) — skipping steam_appid.txt"
fi

if [[ "$ENABLE_STEAM" == "1" ]]; then
  info "Ensure Steam dylib is next to the executable (macOS)"

  STEAM_DYLIB_DEST="$APP_PATH/Contents/MacOS/libsteam_api.dylib"

  if [[ ! -f "$STEAM_DYLIB_SRC" ]]; then
    die "Steam dylib source not found: $STEAM_DYLIB_SRC"
  fi

  cp -fv "$STEAM_DYLIB_SRC" "$STEAM_DYLIB_DEST"

  echo "Signing Steam dylib: $STEAM_DYLIB_DEST" >&3
  /usr/bin/codesign --force --options runtime --timestamp --sign "$SIGN_IDENTITY" "$STEAM_DYLIB_DEST"
else
  info "Steam disabled (ENABLE_STEAM=0) — skipping libsteam_api.dylib staging"
fi

TMP_PREFIX="$(sanitize_name_for_tmp "$SHORT_NAME")"
# Entitlements: hardened runtime is required for Developer ID signing.
# Steam overlay / Steam client libraries may require disabling library validation.
# Only enable those entitlements when you actually need them.
ENTITLEMENTS_FILE="$(/usr/bin/mktemp -t ${TMP_PREFIX}_entitlements_XXXXXX.plist)"

if [[ "$ENABLE_STEAM" == "1" ]]; then
  cat > "$ENTITLEMENTS_FILE" <<'PLIST'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>com.apple.security.cs.disable-library-validation</key>
  <true/>
  <key>com.apple.security.cs.allow-dyld-environment-variables</key>
  <true/>
</dict>
</plist>
PLIST
else
  # Minimal entitlements file. Keeping it empty is valid for many apps.
  cat > "$ENTITLEMENTS_FILE" <<'PLIST'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict/>
</plist>
PLIST
fi

echo "Using signing identity: $SIGN_IDENTITY" >&3

echo "Re-signing app bundle (deep) to seal added dylib" >&3
/usr/bin/codesign --force --deep --options runtime --timestamp --entitlements "$ENTITLEMENTS_FILE" --sign "$SIGN_IDENTITY" "$APP_PATH"

echo "== Validations (fail fast) ==" >&3

# Resolve the actual executable name from Info.plist
APP_EXE_NAME=$(/usr/bin/defaults read "$APP_PATH/Contents/Info.plist" CFBundleExecutable 2>/dev/null || true)
if [[ -z "${APP_EXE_NAME:-}" ]]; then
  echo "ERROR: Could not read CFBundleExecutable from Info.plist" >&3
  exit 6
fi
EXE_PATH="$APP_PATH/Contents/MacOS/$APP_EXE_NAME"


if [[ ! -f "$EXE_PATH" ]]; then
  echo "ERROR: Expected executable not found: $EXE_PATH" >&3
  exit 7
fi

# Quick sanity: Shipping builds should not have obvious debug/dev markers.
# (This is heuristic; the authoritative check is LogInit: Build: Shipping when running with -log.)
if /usr/bin/strings "$EXE_PATH" | /usr/bin/grep -q "Development"; then
  echo "WARN: Executable contains 'Development' strings. If you see on-screen debug in-game, confirm LogInit shows Shipping." >&3
fi

# 1) If Steam is enabled, verify the main exe references Steam as @loader_path
if [[ "$ENABLE_STEAM" == "1" ]]; then
  /usr/bin/otool -L "$EXE_PATH" | /usr/bin/grep -q "@loader_path/libsteam_api.dylib" || {
    echo "ERROR: Executable does not reference @loader_path/libsteam_api.dylib" >&3
    /usr/bin/otool -L "$EXE_PATH" | /usr/bin/grep steam || true
    exit 8
  }
fi

# 2) Verify signatures strictly (no || true)
/usr/bin/codesign --verify --deep --strict --verbose=2 "$APP_PATH"

# 2b) Show entitlements (log proof)
echo "-- Entitlements (app) --" >&3
ENT_OUT=$(/usr/bin/codesign -d --entitlements :- "$APP_PATH" 2>/dev/null || true)
echo "$ENT_OUT" >&3

if [[ "$ENABLE_STEAM" == "1" ]]; then
  echo "$ENT_OUT" | /usr/bin/grep -n "disable-library-validation" >&3 || { die "disable-library-validation entitlement not present (required for some Steam client/overlay scenarios)"; }
  echo "$ENT_OUT" | /usr/bin/grep -n "allow-dyld-environment-variables" >&3 || { die "allow-dyld-environment-variables entitlement not present (Steam overlay commonly needs this)"; }
fi

# 3) Show team IDs in log for confidence
/usr/bin/codesign -dv --verbose=4 "$APP_PATH" 2>&1 | /usr/bin/grep -E "^(Authority=|TeamIdentifier=)" || true

if [[ "$ENABLE_STEAM" == "1" ]]; then
  /usr/bin/codesign -dv --verbose=4 "$STEAM_DYLIB_DEST" 2>&1 | /usr/bin/grep -E "^(Authority=|TeamIdentifier=)" || true
fi

# Sanity: ensure TeamIdentifier matches for app + dylib
APP_TEAM=$(/usr/bin/codesign -dv --verbose=4 "$APP_PATH" 2>&1 | /usr/bin/awk -F'=' '/^TeamIdentifier=/{print $2; exit}')

if [[ "$ENABLE_STEAM" == "1" ]]; then
  DYLIB_TEAM=$(/usr/bin/codesign -dv --verbose=4 "$STEAM_DYLIB_DEST" 2>&1 | /usr/bin/awk -F'=' '/^TeamIdentifier=/{print $2; exit}')

  echo "TeamIdentifier (app):   ${APP_TEAM:-<none>}" >&3
  echo "TeamIdentifier (dylib): ${DYLIB_TEAM:-<none>}" >&3
  if [[ -n "${APP_TEAM:-}" && -n "${DYLIB_TEAM:-}" && "$APP_TEAM" != "$DYLIB_TEAM" ]]; then
    echo "ERROR: TeamIdentifier mismatch between app and libsteam_api.dylib (dyld will refuse to load it)." >&3
    exit 5
  fi
else
  echo "TeamIdentifier (app):   ${APP_TEAM:-<none>}" >&3
fi

if [[ "$DO_NOTARIZE" -eq 0 ]]; then
  echo "== Zip app for notarization (no extra parent) ==" >&3
  /usr/bin/ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" "$ZIP_PATH"
  echo "Zip: $ZIP_PATH" >&3

  echo "== Notarize ==" >&3
  /usr/bin/xcrun notarytool submit "$ZIP_PATH" --keychain-profile "$NOTARY_PROFILE" --wait

  echo "== Staple ==" >&3
  /usr/bin/xcrun stapler staple "$APP_PATH"

  echo "== Staple validation ==" >&3
  /usr/bin/xcrun stapler validate "$APP_PATH" || true

  echo "== Gatekeeper assessment ==" >&3
  /usr/sbin/spctl -a -vv "$APP_PATH" || true
else
  echo "== Skipping zip/notarization/stapling (per prompt) ==" >&3
fi

echo "REMINDER: Test your distribution path." >&3
echo "  - If distributing via a launcher (Steam, Epic, etc.), test launching from that launcher." >&3
echo "  - If distributing direct-download, test on a separate Mac (or a clean user account) with Gatekeeper enabled." >&3

echo "✅ Done" >&3
echo "App: $APP_PATH" >&3
echo "Zip: $ZIP_PATH" >&3

# Cleanup temp entitlements file
rm -f "$ENTITLEMENTS_FILE" 2>/dev/null || true
